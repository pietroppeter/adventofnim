<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>2021\day15.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css/'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/dark.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/androidstudio.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}
</style>
  
  <script async defer data-domain="pietroppeter.github.io/adventofnim" src="https://plausible.io/js/plausible.js"></script>
  <style>
    a {
        text-decoration: none;
        color: #009900;
    }
  
    a:hover {
        color: #99ff99;
    }
  
    em {
        color: #ffffff;
        font-style: normal;
        text-shadow: 0 0 5px #ffffff;
    }
  
    em.star {
      font-style: normal;
      color: #ffff66;
      text-shadow: 0 0 5px #ffff66;
    }
  </style>
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>2021\day15.nim</code></span>
  <span><a href="https://github.com/pietroppeter/adventofnim"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle; fill: #fff" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path></svg></a></span>
</div>
<hr>
</header><main>
<h2>Day 15: <a href="https://adventofcode.com/2021/day/15">Chiton</a></h2>
<p>Today is about path search on a grid. I tend to struggle with these
since I never properly studied the theory.</p>
<h3>Part 1</h3>
<p>We need to go from top left to bottom right minimizing sum of risk.
My strategy will be to create from given grid a new grid that
at every &quot;node&quot; (it usually pays to think of these problems in terms of graphs),
will tell me the direction I should come from in order to minimize the risk and
get there. The final path will be found by following directions from bottom right.</p>
<p>Here are the inputs:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span>
  testInput = <span class="hljs-string">&quot;&quot;&quot;
1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581&quot;&quot;&quot;</span>
  puzzleInput = readFile(<span class="hljs-string">&quot;2021/input15.txt&quot;</span>)</code></pre>
<p>I will be using grid code from my Day09 (no blogpost published),
copying and pasting here the useful bits (I will need to think of an ergonomic
way to import from a notebook). I am also fine with having a sentinel value
for stuff outside the grid that is a high value.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">type</span>
  <span class="hljs-type">Coord</span> = <span class="hljs-keyword">tuple</span>[x, y: <span class="hljs-built_in">int</span>]
  <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
    data: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]
    yLen, xLen: <span class="hljs-built_in">int</span>
    sentinel: <span class="hljs-type">T</span>  <span class="hljs-comment"># value for outside the grid</span>
  <span class="hljs-type">GridInt</span> = <span class="hljs-type">Grid</span>[<span class="hljs-built_in">int</span>]
  <span class="hljs-type">Dir</span> = <span class="hljs-keyword">enum</span>
    right, down, left, up

<span class="hljs-keyword">func</span> isOutside[<span class="hljs-type">T</span>](c: <span class="hljs-type">Coord</span>, g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>]): <span class="hljs-built_in">bool</span> =
  c.x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c.x &gt;= g.xLen <span class="hljs-keyword">or</span> c.y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c.y &gt;= g.yLen

<span class="hljs-keyword">func</span> toIndex[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>], c: <span class="hljs-type">Coord</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">if</span> c.isOutside(g):
    -<span class="hljs-number">1</span>
  <span class="hljs-keyword">else</span>:
    c.y*g.xLen + c.x

<span class="hljs-keyword">func</span> `[]`[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>], c: <span class="hljs-type">Coord</span>): <span class="hljs-type">T</span> =
  <span class="hljs-keyword">let</span> i = g.toIndex(c)
  <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:
    g.sentinel
  <span class="hljs-keyword">else</span>:
    g.data[i]

<span class="hljs-keyword">func</span> parseInt(c: <span class="hljs-built_in">char</span>): <span class="hljs-built_in">int</span> =
  <span class="hljs-literal">result</span> = ord(c) - ord(<span class="hljs-string">'0'</span>)
  <span class="hljs-keyword">assert</span> <span class="hljs-literal">result</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">result</span> &lt;= <span class="hljs-number">9</span>

<span class="hljs-keyword">func</span> parse(text: <span class="hljs-built_in">string</span>): <span class="hljs-type">GridInt</span> =
  <span class="hljs-comment"># result.data = newSeqOfCap(text.len)</span>
  <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> text.strip.splitLines:
    <span class="hljs-literal">result</span>.data.add line.toSeq.map(parseInt)
    inc <span class="hljs-literal">result</span>.yLen
    <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span>.xLen == <span class="hljs-number">0</span>:
      <span class="hljs-literal">result</span>.xLen = line.len
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">assert</span> line.len == <span class="hljs-literal">result</span>.xLen
  <span class="hljs-literal">result</span>.sentinel = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>

<span class="hljs-keyword">iterator</span> coords[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Coord</span> =
  <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; g.yLen:
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; g.xLen:
      <span class="hljs-keyword">yield</span> (x, y)

<span class="hljs-keyword">func</span> `+`(c: <span class="hljs-type">Coord</span>, dir: <span class="hljs-type">Dir</span>): <span class="hljs-type">Coord</span> =
  <span class="hljs-keyword">case</span> dir
  <span class="hljs-keyword">of</span> right:
    (c.x + <span class="hljs-number">1</span>, c.y)
  <span class="hljs-keyword">of</span> down:
    (c.x, c.y + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">of</span> left:
    (c.x - <span class="hljs-number">1</span>, c.y)
  <span class="hljs-keyword">of</span> up:
    (c.x, c.y - <span class="hljs-number">1</span>)</code></pre>
<p>Let's use it to parse inputs:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span>
  testGrid = parse testInput
  puzzleGrid = parse puzzleInput
dump (testGrid.xlen, testGrid.ylen)
dump (puzzleGrid.xlen, puzzleGrid.ylen)
dump testGrid.sentinel</code></pre>
<pre><samp>(testGrid.xlen, testGrid.ylen) = (10, 10)
(puzzleGrid.xlen, puzzleGrid.ylen) = (100, 100)
testGrid.sentinel = 9223372036854775807
</samp></pre>
<p>I am not using a <code>GridDiff</code> (I did not copy related code),
I will be using a <code>GridRisk</code> which will tell
me minimal total risk up to here and best direction I should come from.</p>
<p>I will also use show functions to debug.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">type</span>
  <span class="hljs-type">Risk</span> = <span class="hljs-keyword">tuple</span>[risk: <span class="hljs-built_in">int</span>, dir: <span class="hljs-type">Dir</span>]
  <span class="hljs-type">GridRisk</span> = <span class="hljs-type">Grid</span>[<span class="hljs-type">Risk</span>]

<span class="hljs-keyword">func</span> show(g: <span class="hljs-type">GridInt</span>): <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
    <span class="hljs-literal">result</span>.add $g[c]
    <span class="hljs-keyword">if</span> c.x == g.xLen - <span class="hljs-number">1</span>:
      <span class="hljs-literal">result</span>.add <span class="hljs-string">'\n'</span>

<span class="hljs-keyword">func</span> show(g: <span class="hljs-type">GridRisk</span>, paddingCount=<span class="hljs-number">4</span>): <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
    <span class="hljs-literal">result</span>.add align($(g[c].risk), paddingCount)
    <span class="hljs-keyword">if</span> c.x == g.xLen - <span class="hljs-number">1</span>:
      <span class="hljs-literal">result</span>.add <span class="hljs-string">'\n'</span>

<span class="hljs-keyword">echo</span> show testGrid</code></pre>
<pre><samp>1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581

</samp></pre>
<p>Here is the heart of the problem. Key for this is realizing
how to compute incrementally compute the risk.</p>
<pre><code class="nim hljs"><span class="hljs-keyword">func</span> computeRisk(g: <span class="hljs-type">GridInt</span>, gr: <span class="hljs-type">GridRisk</span>, c: <span class="hljs-type">Coord</span>): <span class="hljs-type">Risk</span> =
  <span class="hljs-comment">## Computes Risk at Coord assuming Risk has been computed</span>
  <span class="hljs-comment">## for cells on the left and above</span>
  <span class="hljs-keyword">let</span>
    riskUp = gr[c + up].risk + g[c]
    riskLeft = gr[c + left].risk + g[c]
  <span class="hljs-comment">#debugEcho &quot;computeRisk for c: &quot;, c</span>
  <span class="hljs-comment">#debugEcho &quot;  riskUp: &quot;, riskUp</span>
  <span class="hljs-comment">#debugEcho &quot;  riskLeft: &quot;, riskLeft</span>
  <span class="hljs-keyword">if</span> riskUp &lt;= riskLeft:
    (riskUp, up)
  <span class="hljs-keyword">else</span>:
    (riskLeft, left)

<span class="hljs-keyword">func</span> computeGridRisk(g: <span class="hljs-type">GridInt</span>): <span class="hljs-type">GridRisk</span> =
  <span class="hljs-literal">result</span>.xLen = g.xLen
  <span class="hljs-literal">result</span>.yLen = g.ylen
  <span class="hljs-literal">result</span>.sentinel = (g.sentinel - <span class="hljs-number">10</span>, up) <span class="hljs-comment"># forgot this line on first try</span>
  <span class="hljs-comment"># need to do - 10 to avoid overflow</span>
  <span class="hljs-literal">result</span>.data = @[(<span class="hljs-number">0</span>, up)]  <span class="hljs-comment"># risk for initial position does not count</span>
  <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
    <span class="hljs-keyword">if</span> c == (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>): <span class="hljs-keyword">continue</span>
    <span class="hljs-literal">result</span>.data.add g.computeRisk(<span class="hljs-literal">result</span>, c)

<span class="hljs-keyword">func</span> part1(gr: <span class="hljs-type">GridRisk</span>): <span class="hljs-built_in">int</span> =
  gr[(gr.xLen - <span class="hljs-number">1</span>, gr.yLen - <span class="hljs-number">1</span>)].risk

<span class="hljs-keyword">let</span>
  testGridRisk = computeGridRisk testGrid
  puzzleGridRisk = computeGridRisk puzzleGrid

<span class="hljs-keyword">echo</span> show testGridRisk

dump part1 testGridRisk
dump part1 puzzleGridRisk <span class="hljs-comment"># 719 wrong, too high!</span></code></pre>
<pre><samp>   0   1   7  10  17  22  23  30  34  36
   1   4  12  11  14  21  24  30  37  38
   3   4   7  13  18  19  20  23  25  33
   6  10  16  17  26  22  21  26  31  40
  13  14  20  20  24  23  28  27  28  29
  14  17  18  27  25  25  33  28  31  36
  15  18  23  32  34  26  28  32  33  34
  18  19  21  26  30  28  29  35  36  43
  19  21  30  29  30  31  37  40  38  39
  21  24  25  26  35  35  39  44  46  40

part1 testGridRisk = 40
part1 puzzleGridRisk = 719
</samp></pre>
<p>I am stuck at the moment with <em>a correct test result and an incorrect
puzzle result</em>. Not really sure how to debug.</p>
<p>... after looking at our discord aoc I got a useful hint (thanks @Michal58!),
the example only gives a path where the solution only goes down and to the right
and this was also my (wrong) assumption! It is indeed possible
for a minimal solution to wiggle around all directions but
my algorithm for sure is not going to find it.</p>
<p>So I really need to implement some <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>
or <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">A*</a> algorithm!</p>
<p>But first let me give a minimal example that makes it clear why I need
the better approach:</p>
<pre><code class="nim hljs"><span class="hljs-keyword">let</span>
  hintInput = <span class="hljs-string">&quot;19999</span><span class="hljs-meta">\n</span><span class="hljs-string">19111</span><span class="hljs-meta">\n</span><span class="hljs-string">11191&quot;</span>
  hintGrid = parse hintInput
  hintGridRisk = computeGridRisk hintGrid

<span class="hljs-keyword">echo</span> show hintGrid, <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>, show hintGridRisk</code></pre>
<pre><samp>19999
19111
11191

   0   9  18  27  36
   1  10  11  12  13
   2   3   4  13  14

</samp></pre>
<p>&quot;
... <em>(a few hours later) back to writing the blogpost and writing my solution</em>.</p>
<p>This morning I shared the hint on <a href="https://www.reddit.com/r/adventofcode/comments/rgszh7/2021_day_15_part_1_hint_if_you_get_correct_answer/">advent of code subreddit</a>
and it has been quite popular!</p>
<p>The irony is that I have not yet taken advantage of the hint and finalized my solution üòÅ, so let's get to it.</p>
<p>I will implement Dijkstra's algorithm because it is simpler than A* (although in general less powerful) and also because of its
<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#History#:~:text=it%20was%20a%20twenty,pencil%20and%20paper">compelling history</a>
(did you open last link on a chromium based browser? did you know what <a href="https://web.dev/text-fragments/">text-fragments</a> are?
I didn't but having seen some weird highlighted stuff after google results I got curious...).
&quot;</p>

</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> animu, nimib

nbInit(theme=useAdventOfNim)
nbText: <span class="hljs-string">&quot;&quot;&quot;## Day 15: [Chiton](https://adventofcode.com/2021/day/15)

Today is about path search on a grid. I tend to struggle with these
since I never properly studied the theory.

### Part 1

We need to go from top left to bottom right minimizing sum of risk.
My strategy will be to create from given grid a new grid that
at every &quot;node&quot; (it usually pays to think of these problems in terms of graphs),
will tell me the direction I should come from in order to minimize the risk and
get there. The final path will be found by following directions from bottom right.

Here are the inputs:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span>
    testInput = <span class="hljs-string">&quot;&quot;&quot;
1163751742
1381373672
2136511328
3694931569
7463417111
1319128137
1359912421
3125421639
1293138521
2311944581&quot;&quot;&quot;</span>
    puzzleInput = readFile(<span class="hljs-string">&quot;2021/input15.txt&quot;</span>)
nbText: <span class="hljs-string">&quot;&quot;&quot;I will be using grid code from my Day09 (no blogpost published),
copying and pasting here the useful bits (I will need to think of an ergonomic
way to import from a notebook). I am also fine with having a sentinel value
for stuff outside the grid that is a high value.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Coord</span> = <span class="hljs-keyword">tuple</span>[x, y: <span class="hljs-built_in">int</span>]
    <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>] = <span class="hljs-keyword">object</span>
      data: <span class="hljs-built_in">seq</span>[<span class="hljs-type">T</span>]
      yLen, xLen: <span class="hljs-built_in">int</span>
      sentinel: <span class="hljs-type">T</span>  <span class="hljs-comment"># value for outside the grid</span>
    <span class="hljs-type">GridInt</span> = <span class="hljs-type">Grid</span>[<span class="hljs-built_in">int</span>]
    <span class="hljs-type">Dir</span> = <span class="hljs-keyword">enum</span>
      right, down, left, up

  <span class="hljs-keyword">func</span> isOutside[<span class="hljs-type">T</span>](c: <span class="hljs-type">Coord</span>, g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>]): <span class="hljs-built_in">bool</span> =
    c.x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c.x &gt;= g.xLen <span class="hljs-keyword">or</span> c.y &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> c.y &gt;= g.yLen

  <span class="hljs-keyword">func</span> toIndex[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>], c: <span class="hljs-type">Coord</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-keyword">if</span> c.isOutside(g):
      -<span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
      c.y*g.xLen + c.x

  <span class="hljs-keyword">func</span> `[]`[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>], c: <span class="hljs-type">Coord</span>): <span class="hljs-type">T</span> =
    <span class="hljs-keyword">let</span> i = g.toIndex(c)
    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span>:
      g.sentinel
    <span class="hljs-keyword">else</span>:
      g.data[i]

  <span class="hljs-keyword">func</span> parseInt(c: <span class="hljs-built_in">char</span>): <span class="hljs-built_in">int</span> =
    <span class="hljs-literal">result</span> = ord(c) - ord(<span class="hljs-string">'0'</span>)
    <span class="hljs-keyword">assert</span> <span class="hljs-literal">result</span> &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">result</span> &lt;= <span class="hljs-number">9</span>

  <span class="hljs-keyword">func</span> parse(text: <span class="hljs-built_in">string</span>): <span class="hljs-type">GridInt</span> =
    <span class="hljs-comment"># result.data = newSeqOfCap(text.len)</span>
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> text.strip.splitLines:
      <span class="hljs-literal">result</span>.data.add line.toSeq.map(parseInt)
      inc <span class="hljs-literal">result</span>.yLen
      <span class="hljs-keyword">if</span> <span class="hljs-literal">result</span>.xLen == <span class="hljs-number">0</span>:
        <span class="hljs-literal">result</span>.xLen = line.len
      <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">assert</span> line.len == <span class="hljs-literal">result</span>.xLen
    <span class="hljs-literal">result</span>.sentinel = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">high</span>

  <span class="hljs-keyword">iterator</span> coords[<span class="hljs-type">T</span>](g: <span class="hljs-type">Grid</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Coord</span> =
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; g.yLen:
      <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; g.xLen:
        <span class="hljs-keyword">yield</span> (x, y)

  <span class="hljs-keyword">func</span> `+`(c: <span class="hljs-type">Coord</span>, dir: <span class="hljs-type">Dir</span>): <span class="hljs-type">Coord</span> =
    <span class="hljs-keyword">case</span> dir
    <span class="hljs-keyword">of</span> right:
      (c.x + <span class="hljs-number">1</span>, c.y)
    <span class="hljs-keyword">of</span> down:
      (c.x, c.y + <span class="hljs-number">1</span>)
    <span class="hljs-keyword">of</span> left:
      (c.x - <span class="hljs-number">1</span>, c.y)
    <span class="hljs-keyword">of</span> up:
      (c.x, c.y - <span class="hljs-number">1</span>)
nbText: <span class="hljs-string">&quot;&quot;&quot;
Let's use it to parse inputs:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span>
    testGrid = parse testInput
    puzzleGrid = parse puzzleInput
  dump (testGrid.xlen, testGrid.ylen)
  dump (puzzleGrid.xlen, puzzleGrid.ylen)
  dump testGrid.sentinel
nbText: <span class="hljs-string">&quot;&quot;&quot;
I am not using a `GridDiff` (I did not copy related code),
I will be using a `GridRisk` which will tell
me minimal total risk up to here and best direction I should come from.

I will also use show functions to debug.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">type</span>
    <span class="hljs-type">Risk</span> = <span class="hljs-keyword">tuple</span>[risk: <span class="hljs-built_in">int</span>, dir: <span class="hljs-type">Dir</span>]
    <span class="hljs-type">GridRisk</span> = <span class="hljs-type">Grid</span>[<span class="hljs-type">Risk</span>]

  <span class="hljs-keyword">func</span> show(g: <span class="hljs-type">GridInt</span>): <span class="hljs-built_in">string</span> =
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
      <span class="hljs-literal">result</span>.add $g[c]
      <span class="hljs-keyword">if</span> c.x == g.xLen - <span class="hljs-number">1</span>:
        <span class="hljs-literal">result</span>.add <span class="hljs-string">'\n'</span>

  <span class="hljs-keyword">func</span> show(g: <span class="hljs-type">GridRisk</span>, paddingCount=<span class="hljs-number">4</span>): <span class="hljs-built_in">string</span> =
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
      <span class="hljs-literal">result</span>.add align($(g[c].risk), paddingCount)
      <span class="hljs-keyword">if</span> c.x == g.xLen - <span class="hljs-number">1</span>:
        <span class="hljs-literal">result</span>.add <span class="hljs-string">'\n'</span>

  <span class="hljs-keyword">echo</span> show testGrid
nbText: <span class="hljs-string">&quot;&quot;&quot;
Here is the heart of the problem. Key for this is realizing
how to compute incrementally compute the risk.
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">func</span> computeRisk(g: <span class="hljs-type">GridInt</span>, gr: <span class="hljs-type">GridRisk</span>, c: <span class="hljs-type">Coord</span>): <span class="hljs-type">Risk</span> =
    <span class="hljs-comment">## Computes Risk at Coord assuming Risk has been computed</span>
    <span class="hljs-comment">## for cells on the left and above</span>
    <span class="hljs-keyword">let</span>
      riskUp = gr[c + up].risk + g[c]
      riskLeft = gr[c + left].risk + g[c]
    <span class="hljs-comment">#debugEcho &quot;computeRisk for c: &quot;, c</span>
    <span class="hljs-comment">#debugEcho &quot;  riskUp: &quot;, riskUp</span>
    <span class="hljs-comment">#debugEcho &quot;  riskLeft: &quot;, riskLeft</span>
    <span class="hljs-keyword">if</span> riskUp &lt;= riskLeft:
      (riskUp, up)
    <span class="hljs-keyword">else</span>:
      (riskLeft, left)

  <span class="hljs-keyword">func</span> computeGridRisk(g: <span class="hljs-type">GridInt</span>): <span class="hljs-type">GridRisk</span> =
    <span class="hljs-literal">result</span>.xLen = g.xLen
    <span class="hljs-literal">result</span>.yLen = g.ylen
    <span class="hljs-literal">result</span>.sentinel = (g.sentinel - <span class="hljs-number">10</span>, up) <span class="hljs-comment"># forgot this line on first try</span>
    <span class="hljs-comment"># need to do - 10 to avoid overflow</span>
    <span class="hljs-literal">result</span>.data = @[(<span class="hljs-number">0</span>, up)]  <span class="hljs-comment"># risk for initial position does not count</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> g.coords:
      <span class="hljs-keyword">if</span> c == (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>): <span class="hljs-keyword">continue</span>
      <span class="hljs-literal">result</span>.data.add g.computeRisk(<span class="hljs-literal">result</span>, c)

  <span class="hljs-keyword">func</span> part1(gr: <span class="hljs-type">GridRisk</span>): <span class="hljs-built_in">int</span> =
    gr[(gr.xLen - <span class="hljs-number">1</span>, gr.yLen - <span class="hljs-number">1</span>)].risk
  
  <span class="hljs-keyword">let</span>
    testGridRisk = computeGridRisk testGrid
    puzzleGridRisk = computeGridRisk puzzleGrid

  <span class="hljs-keyword">echo</span> show testGridRisk

  dump part1 testGridRisk
  dump part1 puzzleGridRisk <span class="hljs-comment"># 719 wrong, too high!</span>
nbText: <span class="hljs-string">&quot;&quot;&quot;
I am stuck at the moment with _a correct test result and an incorrect
puzzle result_. Not really sure how to debug.

... after looking at our discord aoc I got a useful hint (thanks @Michal58!),
the example only gives a path where the solution only goes down and to the right
and this was also my (wrong) assumption! It is indeed possible
for a minimal solution to wiggle around all directions but
my algorithm for sure is not going to find it.

So I really need to implement some [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
or [A*](https://en.wikipedia.org/wiki/A*_search_algorithm) algorithm!

But first let me give a minimal example that makes it clear why I need
the better approach:
&quot;&quot;&quot;</span>
nbCode:
  <span class="hljs-keyword">let</span>
    hintInput = <span class="hljs-string">&quot;19999</span><span class="hljs-meta">\n</span><span class="hljs-string">19111</span><span class="hljs-meta">\n</span><span class="hljs-string">11191&quot;</span>
    hintGrid = parse hintInput
    hintGridRisk = computeGridRisk hintGrid
  
  <span class="hljs-keyword">echo</span> show hintGrid, <span class="hljs-string">&quot;</span><span class="hljs-meta">\n</span><span class="hljs-string">&quot;</span>, show hintGridRisk
nbText: <span class="hljs-string">&quot;&quot;&quot;&quot;
... _(a few hours later) back to writing the blogpost and writing my solution_.

This morning I shared the hint on [advent of code subreddit](https://www.reddit.com/r/adventofcode/comments/rgszh7/2021_day_15_part_1_hint_if_you_get_correct_answer/)
and it has been quite popular!

The irony is that I have not yet taken advantage of the hint and finalized my solution üòÅ, so let's get to it.

I will implement Dijkstra's algorithm because it is simpler than A* (although in general less powerful) and also because of its
[compelling history](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm#History#:~:text=it%20was%20a%20twenty,pencil%20and%20paper)
(did you open last link on a chromium based browser? did you know what [text-fragments](https://web.dev/text-fragments/) are?
I didn't but having seen some weird highlighted stuff after google results I got curious...).
&quot;&quot;&quot;&quot;</span>


nbSave
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>